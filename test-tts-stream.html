<!DOCTYPE html>
<html>
<head>
  <title>Test Gemini TTS Streaming</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
    }
    textarea {
      width: 100%;
      height: 100px;
      margin: 10px 0;
    }
    button {
      padding: 10px 20px;
      background: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 16px;
    }
    button:hover {
      background: #45a049;
    }
    #status {
      margin-top: 20px;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <h1>üé§ Gemini TTS Streaming Test</h1>
  
  <div>
    <label>–¢–µ–∫—Å—Ç –¥–ª—è —Å–∏–Ω—Ç–µ–∑–∞:</label>
    <textarea id="textInput">–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ —Ç–µ—Å—Ç streaming TTS —á–µ—Ä–µ–∑ Gemini.</textarea>
  </div>
  
  <div>
    <label>–ì–æ–ª–æ—Å:</label>
    <select id="voiceSelect">
      <option value="Aoede">Aoede (–∂–µ–Ω—Å–∫–∏–π, —Ä–∞—Å—Å–∫–∞–∑—á–∏–∫)</option>
      <option value="Kore">Kore (–∂–µ–Ω—Å–∫–∏–π)</option>
      <option value="Charon">Charon (–º—É–∂—Å–∫–æ–π)</option>
      <option value="Puck">Puck</option>
    </select>
  </div>
  
  <div>
    <label>–ú–æ–¥–µ–ª—å:</label>
    <select id="modelSelect">
      <option value="gemini-2.5-flash-preview-tts">gemini-2.5-flash-preview-tts</option>
      <option value="gemini-2.5-pro-preview-tts">gemini-2.5-pro-preview-tts</option>
    </select>
  </div>
  
  <button onclick="testStreaming()">üéµ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∞—É–¥–∏–æ</button>
  
  <div id="status"></div>
  <audio id="audioPlayer" controls style="margin-top: 20px; width: 100%;"></audio>

  <script>
    const API_BASE_URL = window.location.origin; // –∏–ª–∏ 'http://localhost:4000'

    async function testStreaming() {
      const text = document.getElementById('textInput').value;
      const voiceName = document.getElementById('voiceSelect').value;
      const modelName = document.getElementById('modelSelect').value;
      const statusDiv = document.getElementById('status');
      const audioPlayer = document.getElementById('audioPlayer');

      if (!text.trim()) {
        statusDiv.innerHTML = '<span style="color: red;">‚ùå –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç!</span>';
        return;
      }

      statusDiv.innerHTML = 'üîÑ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞—É–¥–∏–æ...';

      try {
        const response = await fetch(`${API_BASE_URL}/api/tts-stream`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            text,
            voiceName,
            modelName
          })
        });

        if (!response.ok) {
          const error = await response.json();
          statusDiv.innerHTML = `<span style="color: red;">‚ùå –û—à–∏–±–∫–∞: ${error.message || error.error}</span>`;
          return;
        }

        // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö
        const reader = response.body.getReader();
        const chunks = [];
        let totalSize = 0;

        statusDiv.innerHTML = 'üì¶ –ü–æ–ª—É—á–µ–Ω–∏–µ –∞—É–¥–∏–æ...';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          chunks.push(value);
          totalSize += value.length;
          statusDiv.innerHTML = `üì¶ –ü–æ–ª—É—á–µ–Ω–æ: ${totalSize} bytes...`;
        }

        // –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ —á–∞–Ω–∫–∏
        const audioBuffer = new Uint8Array(totalSize);
        let offset = 0;
        for (const chunk of chunks) {
          audioBuffer.set(chunk, offset);
          offset += chunk.length;
        }

        // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º PCM –≤ WAV –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –≤ –±—Ä–∞—É–∑–µ—Ä–µ
        const sampleRate = parseInt(response.headers.get('X-Audio-Sample-Rate') || '24000');
        const channels = parseInt(response.headers.get('X-Audio-Channels') || '1');
        const bitsPerSample = parseInt(response.headers.get('X-Audio-Bits-Per-Sample') || '16');

        const wavBuffer = createWAVFile(audioBuffer, sampleRate, channels, bitsPerSample);
        const blob = new Blob([wavBuffer], { type: 'audio/wav' });
        const url = URL.createObjectURL(blob);

        audioPlayer.src = url;
        statusDiv.innerHTML = `<span style="color: green;">‚úÖ –ê—É–¥–∏–æ –≥–æ—Ç–æ–≤–æ! –†–∞–∑–º–µ—Ä: ${totalSize} bytes</span>`;

      } catch (error) {
        statusDiv.innerHTML = `<span style="color: red;">‚ùå –û—à–∏–±–∫–∞: ${error.message}</span>`;
        console.error('Error:', error);
      }
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è WAV —Ñ–∞–π–ª–∞ –∏–∑ PCM –¥–∞–Ω–Ω—ã—Ö
    function createWAVFile(pcmData, sampleRate, channels, bitsPerSample) {
      const byteRate = sampleRate * channels * (bitsPerSample / 8);
      const blockAlign = channels * (bitsPerSample / 8);
      const dataSize = pcmData.length;
      const fileSize = 36 + dataSize;

      const buffer = new ArrayBuffer(44 + dataSize);
      const view = new DataView(buffer);

      // RIFF header
      view.setUint32(0, 0x46464952, true); // "RIFF"
      view.setUint32(4, fileSize, true);
      view.setUint32(8, 0x45564157, true); // "WAVE"

      // fmt chunk
      view.setUint32(12, 0x20746d66, true); // "fmt "
      view.setUint32(16, 16, true); // chunk size
      view.setUint16(20, 1, true); // audio format (PCM)
      view.setUint16(22, channels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitsPerSample, true);

      // data chunk
      view.setUint32(36, 0x61746164, true); // "data"
      view.setUint32(40, dataSize, true);

      // PCM data
      const pcmView = new Uint8Array(buffer, 44);
      pcmView.set(pcmData);

      return buffer;
    }
  </script>
</body>
</html>

